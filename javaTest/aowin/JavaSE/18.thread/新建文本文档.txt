线程的创建


线程的属性


线程的方法


线程安全问题：
         多个线程操作同一个数据造成数据错误
    解决：同步==》线程必须获取到对象的钥匙（只有一个）之后才能执行同步内容，
		一旦一个线程拿走了钥匙，其它线程就不能再执行同步内容

同步synchronized：  
同步方法    :
	非静态方法，同步的是调用方法的那个对象
	静态方法，同步的是当前类的Class对象
 同步代码块
	synchronized(同步对象){}


同步可以解决线程安全问题，但是使用不当可能造成死锁

针对的是使用同一个资源对象的多个线程之间，可以通过资源对象进行通信：
在同步代码块中，一个线程中调用对象的wait()方法，这个线程释放占用的对象锁，停止执行，直到其它线程调用这个资源对象的notify()方法（notify()  唤醒一个调用了wait()的线程     notifyAll()唤醒所有的wait()线程）



对比sleep()和wait()
都会造成线程暂停
区别：
1）wait()需要在同步代码中才能执行     sleep()都可以
2）sleep()方法是线程定义的静态方法
     wait()方法是Object中定义的非静态方法
3）sleep()不会释放对象锁，wait()会
4) 一般来说，使用sleep()是为了让线程暂停执行一定的时间，时间到了线程自动醒来
                  wait()需要被唤醒（notify()）














