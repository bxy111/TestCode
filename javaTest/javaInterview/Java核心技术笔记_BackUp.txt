1.  一个方法可以访问所属类的所有对象的私有属性。（C++也有这个原则）

2.  String类是一个不可变类。类中的每个方法都不会改变这个对象。

3.  静态方法只能访问静态属性。

4.  每一个类可以有一个main方法。这是一个常用的对类进行单元测试的技巧。

5.  java总是使用按值传递。方法得到的是所有参数值的一个拷贝。方法不能修改传递给它的任何参数变量的内容。

6.  静态初始化块，在类第一次加载的时候，会进行静态域的初始化。
    初始化块。在一个类的声明中，可以包含多个代码块。只要构造类的对象，这些块就会执行。然后在运行构造器。
    
7.  可以为任何一个类添加 finalize 方法。 finalize 方法将在垃圾回收器清除对象之前调用。在实际应用中，
    不要依赖于使用 finalize 方法回收任何短缺的资源， 这是因为很难知道这个方法什么时候才能够调用。

8.  在 Java 中，不需要将方法声明为虚拟方法。动态绑定是默认的处理方式。如果不希望让一个方法具有虚拟特征，可以将它标记为final。

9.  在覆盖一个方法的时候，子类方法不能低于超类方法的可见性。特别是， 如果超类方法是 public, 子类方法一定要声明为 public。

10. Integer 类型的值在[-128,127] 期间,Integer 用 “==”是可以的   ， Integer  与 int 类型比较（==）比较的是值。

11. 在覆盖一个方法的时候，子类方法不能低于超类方法的可见性。特别是， 如果超类方法是 public, 子类方法一定要声明为 public。

12. 类即使不含抽象方法，也可以将类声明为抽象类。

13. 编译器只允许调用在类中声明的方法。

14. protected修饰符，在同包中不论是子类还是其他的类都可以访问，但是在不同包中，子类可以访问，非子类不能访问。
    事实上，Java中的受保护部分对所有子类及同一个包中的所有其他类都可见。这与c++中的保护机制稍有不同，
    Java中的protected概念要比C++中的安全性差。

15. 1)仅对本类可见private。2)对所有类可见public：3)对本包和所有子类可见protected。4)对本包可见—默认 不需要修饰符。

16. 在 Java 中， 只有基本类型 （ primitive types) 不是对象， 例如，数值、 字符和布尔类型的值都不是对象。

17. 由于 hashCode 方法定义在 Object 类中， 因此每个对象都有一个默认的散列码，其值为对象的存储地址。
    Integer类型的hashcode值就是该对象的值。

18. equals与hashcode的定义必须一致：如果x.equals(y)返回true，那么x.hashCode()就必须与y.hashCode()相同。

19. 强烈建议为自定义的每一个类增加toString方法。数组调用Arrays.toString()静态方法去生成字符串。

20. 鉴于兼容性的考虑， 编译器在对类型转换进行检査之后， 如果没有发现违反规则的现象， 就将所有的类型化数组列表
    转换成原始 ArrayList 对象。

21. 假设想定义一个整型数组列表。而尖括号中的类型参数不允许是基本类型，也就是说，不允许写成 ArrayList<int>。
    我们可以声明一个 Integer对象的数组列表。

22. 下面这个调用ArrayList<Integer> list = new ArrayList<>(); list.add(3);
    将自动地变换成
    list.add(Integer.value0f(3));
    这种变换被称为自动装箱（autoboxing。)
    相反地， 当将一个 Integer 对象赋给一个 int 值时， 将会自动地拆箱。

23. 自动装箱规范要求 boolean、byte、char <= 127，介于-128 ~ 127之间的 short 和
    int 被包装到固定的对象中。例如， 如果在前面的例子中将 a 和 b 初始化为 100， 对它们
    进行比较的结果一定成立。

22. 对于 printf 的实现者来说，Object... 参数类型与 Object[] 完全一样。

23. 反射是一种功能强大且复杂的机制。 使用它的主要人员是工具构造者， 而不是应用程序员。

24. 由于 name 是一个私有域， 所以 get 方法将会抛出一个IllegalAccessException。
    只有利用 get 方法才能得到可访问域的值。除非拥有访问权限，否则Java 安全机制只允许査看任意对象有哪些域，
    而不允许读取它们的值。

25. 反射机制的默认行为受限于 Java 的访问控制。为了达到这个目的， 需要调用 Field、 Method 或
    Constructor 对象的 setAccessible 方法。

26. 如同使用 instanceof检查一个对象是否属于某个特定类一样， 也可以使用instanceof 检查一个对象是否实现了某个特定的接口。

27. 接口中不能包含实例域或静态方法，但却可以包含常量。（1.8之后，接口中可以包含static方法）
    在 Java SE 8 中，允许在接口中增加静态方法。

28. 与接口中的方法都自动地被设置为 public一样， 接口中的域将被自动设为 public static final。

29. 尽管每个类只能够拥有一个超类， 但却可以实现多个接口。

30. 接口可以提供多重继承的大多数好处，同时还能避免多重继承的复杂性和低效性。

31. 在 Java SE 8 中，可以为接口方法提供一个默认实现。

32. "类优先"规则可以确保与 Java SE 7 的兼容性。 如果为一个接口增加默认方法，
    这对于有这个默认方法之前能正常工作的代码不会有任何影响。

33. 如果希望 copy 是一个新对象，它的初始状态与 original 相同， 但是之后它们各自会有自己不同的状态，
    这种情况下就可以使用 clone 方法。

34. Cloneable 接口的出现与接口的正常使用并没有关系。具体来说，它没有指定clone 方法，这个方法是从 Object 类继承的。
    这个接口只是作为一个标记，指示类设计者了解克隆过程。如果一个对象请求克隆， 但没有实现这个接口， 就会生成一个受査异常。

35. Cloneable 接口是 Java 提供的一组标记接口 ( tagging interface ) 之一。标记接口不包含任何方法； 它唯一的作用就是允许
    在类型查询中使用 instanceof。

36. 对于只有一个抽象方法的接口， 需要这种接口的对象时， 就可以提供一个 lambda 表达式，这种接口称为函数式接口。

37. >>>(逻辑右移)运算符会用 0 填充高位，这与>>(算数右移)不同，它会用符号位填充高位。不存在 <<<运算符。<<(左移)低位补零

38. 表达式System.out::println是一个方法引用（ method reference ), 它等价于 lambda 表达式x->System.out.println(x);
    要用::操作符分隔方法名与对象或类名。instanceMethod 实例方法  staticMethod静态方法
    object::instanceMethod;
    Class::staticMethod;
    Class::instanceMethod;
    System.out::println 等价于 x -> System.out.println(x)
    Math::pow 等价于（x，y) ->Math.pow(x,y)
    对于第 3 种情况， 第 1 个参数会成为方法的目标。例如，String::compareToIgnoreCase 等
    同于 (x, y)-> x.compareToIgnoreCase(y) 0

39. 可以在方法引用中使用 this 参数。 例如， this::equals 等同于 x-> this.equals(x)。 使用super 也是合法的。

40. 构造器引用与方法引用很类似，只不过方法名为 new。 int[]::new 是一个构造器引用，它有一个参数：
    即数组的长度。这等价于 lambda 表达式 x-> new int[x]; Animal[]::new等价于x->new Animal[x];

41. 可以把一个 lambda 表达式转换为包含一个方法的对象，这样自由变量的值就会复制到这个对象的实例变量中;
    关于代码块以及自由变量值有一个术语： 闭包;在 Java 中， lambda 表达式就是闭包;
    在 lambda 表达式中， 只能引用值不会改变的变量;

42. lambda 表达式的体与嵌套块有相同的作用域;在 lambda 表达式中声明与一个局部变量同名的参数或局部变量是不合法的。

43. 在一个 lambda 表达式中使用 this 关键字时， 是指创建这个 lambda 表达式的方法的 this参数;

44. 类定义中的类型变量指定方法的返回类型以及域和局部变量的类型。
    类型变量使用大写形式，且比较短，这是很常见的。在Java库中，使用变量E表示集合的元素类型，
    K和V分别表示表的关键字与值的类型。T(需要时还可以用临近的字母U和S)表示“任意类型”。

45. 将T限制为实现了Comparable接口的类，<T extends Comparab1e>。

46. 一个类型变量或通配符可以有多个限定；限定类型用“ &” 分隔，而逗号用来分隔类型变量。
    在 Java 的继承中， 可以根据需要拥有多个接口超类型， 但限定中至多有一个类。如果用一个类作为限定，它必须是限定列表中的第一个。

47. 无论何时定义一个泛型类型，都自动提供了一个相应的原始类型(raw type)。原始类型
    的名字就是删去类型参数后的泛型类型名。擦除（erased)类型变量,并替换为限定类型(无限定的变量用Object。)
    原始类型用第一个限定的类型变量来替换，如果没有给定限定就用Object替换。
    为了提高效率，应该将标签（tagging)接口（即没有方法的接口）放在限定列表的末尾。

48. 需要记住有关Java泛型转换的事实：
    1.虚拟机中没有泛型，只有普通的类和方法。
    2.所有的类型参数都用它们的限定类型替换。
    3.桥方法被合成来保持多态。
    4.为保持类型安全性，必要时插人强制类型转换。

49. 在一个方法覆盖另一个方法时可以指定一个更严格的返回类型。
    在虚拟机中，用参数类型和返回类型确定一个方法。因此， 编译器可能产生两个仅返回类型不同的方法字节码，虚拟机能够正确地处理这一情况。

50. 1.  不能用基本类型实例化类型参数。因此，没有Pair<double>,只有Pair<Double>。当然,其原因是类型擦除，
        擦除之后，Pair类含有Object类型的域，而Object不能存储double值。
    2.  运行时类型查询只适用于原始类型；instanceof
    3.  不能创建参数化类型的数组 Pair<String>[] table = new Pair<String>[10]; // Error
    4.  Varargs 警告。
    5.  不能实例化类型变置。
    6.  不能构造泛型数组。
    7.  泛型类的静态上下文中类型变量无效。（50条有很多限制，没有全部写下来，很晕。。。）

51. 通配符类型Pair<? extends Employee>
    表示任何泛型Pair类型，它的类型参数是Employee的子类，如Pair<Manager>， 但不是Pair<String>。

52. ? super Manager,这个通配符限制为 Manager 的所有超类型。
    -encoding UTF-8
    直观地讲，带有超类型限定的通配符可以向泛型对象写入，带有子类型限定的通配符可以从泛型对象读取。

53. byte -> short（char） -> int -> long -> float -> double
    char和short大小相同，但是他们之间需要相互强转，从低到高自动转换，从高到低需要强转

54. 非静态代码块每次创建实例时执行,而静态代码块只执行一次；静态代码块优先非静态代码块优先构造函数;

55. 如果有任何运算单元的长度超过int,那么运算结果就按照最长的长度计算; int a = 5;long b = 6;a+b -> 结果类型是long
    如果任何运算单元的长度都不超过int,那么运算结果就按照int来计算; byte a = 1; byte b= 2; a+b -> int 类型

56. 任何数和自己进行异或都等于0; 任何数和0进行异或都等于自己;

57. 需要注意的是，如果在通过nextInt()读取了整数后，再接着读取字符串，读出来的是回车换行:"\r\n",因为nextInt仅仅读取数字信息，而不会读取回车换行"\r\n".
    所以，如果在业务上需要读取了整数后，接着读取字符串，那么就应该连续执行两次nextLine()，第一次是取走回车换行，第二次才是读取真正的字符串。
    或者使用next()方法也可以，就不需要调用两次了。

58. switch可以使用byte,short,int,char,String,enum;
    每个表达式结束，都应该有一个break;
    String在Java1.7之前是不支持的, Java从1.7开始支持switch用String的，编译后是把String转化为hash值，其实还是整数;

59. 一旦提供了一个有参的构造方法,同时又没有显式的提供一个无参的构造方法,那么默认的无参的构造方法，就木有了。

60. 如果要在一个构造方法中，调用另一个构造方法，可以使用this;同理super;

61. 访问类属性（静态属性）有两种方式：1. 对象.类属性；2. 类.类属性；这两种方式都可以访问类属性，访问即修改和获取，
    但是建议使用第二种 类.类属性 的方式进行，这样更符合语义上的理解。
    调用类方法(静态方法)也有两种方式1. 对象.类方法；2. 类.类方法；

62. 饿汉式是立即加载的方式，无论是否会用到这个对象，都会加载。如果在构造方法里写了性能消耗较大，占时较久的代码，
    比如建立与数据库的连接，那么就会在启动的时候感觉稍微有些卡顿。

    懒汉式，是延迟加载的方式，只有使用的时候才会加载。 并且有线程安全的考量(鉴于同学们学习的进度，暂时不对线程的章节做展开)。
    使用懒汉式，在启动的时候，会感觉到比饿汉式略快，因为并没有做对象的实例化。 但是在第一次调用的时候，会进行实例化操作，感觉上就略慢。

    看业务需求，如果业务上允许有比较充分的启动和初始化时间，就使用饿汉式，否则就使用懒汉式

63. 什么是单例模式？1. 构造方法私有化;2. 静态属性指向实例;3. public static的 getInstance方法，返回第二步的静态属性

64. 与重写类似，方法的重写是子类覆盖父类的对象方法; 隐藏，就是子类覆盖父类的类方法(静态方法);
    只有对象方法的才算是重写，类方法的则是隐藏，只看调用方的类型（不看内在指向的是谁）;

65. 在类中声明一个方法，这个方法没有实现体，是一个“空”方法;
    这样的方法就叫抽象方法，使用修饰符“abstract"
    当一个类有抽象方法的时候，该类必须被声明为抽象类;
    抽象类可以没有抽象方法;

66. 非静态内部类语法: new 外部类().new 内部类(); 是可以直接访问外部类的属性和方法，就相当于在外部内的内部成员一样。
    静态内部类，语法：new 外部类.静态内部类(); 只能访问外部内的静态属性和方法。
    匿名类指的是在声明一个类的同时实例化它；为了快速使用，直接实例化一个抽象类，并“当场”实现其抽象方法。
    既然实现了抽象方法，那么就是一个新的类，只是这个类，没有命名。这样的类，叫做匿名类
    在匿名类中使用外部的局部变量，外部的局部变量必须修饰为final;

67. 接口中default方法的二义性问题
    1.若一个类A实现的两个接口B和C当中存在一个相同的default方法defaultMethod，则类A必须给出defaultMethod的实现。
    2.若1中是一个接口B和一个类D，则遵从“类优先原则”，不要求A给出defaultMethod的实现。

68. 不同类型之间不能进行自动封箱和拆箱。

69. 然而在不同的操作系统，换行符是不一样的
    1.在DOS和Windows中，每行结尾是 “\r\n”；
    2.Linux系统里，每行结尾只有 “\n”；
    3.Mac系统里，每行结尾是只有 "\r"。
    为了使得同一个java程序的换行符在所有的操作系统中都有一样的表现，使用%n，就可以做到平台无关的换行;

70. immutable 是指不可改变的;不可改变的具体含义是指：不能增加长度,不能减少长度,不能插入字符,不能删除字符,不能修改字符
    一旦创建好这个字符串，里面的内容 永远 不能改变;String 的表现就像是一个常量。

71. throws与throw这两个关键字接近，不过意义不一样，有如下区别：
    1. throws出现在方法声明上，而throw通常都出现在方法体内。
    2. throws表示出现异常的一种可能性，并不一定会发生这些异常；throw则是抛出了异常，执行throw则一定抛出了某个异常对象。

72. 异常分类：可查异常，运行时异常和错误3种,其中，运行时异常和错误又叫非可查异常;
    可查异常： CheckedException
    可查异常即必须进行处理的异常，要么try catch住,要么往外抛，谁调用，谁处理，比如 FileNotFoundException
    如果不处理，编译器，就不让你通过;

    运行时异常RuntimeException指： 不是必须进行try catch的异常
    常见运行时异常:
    除数不能为0异常:ArithmeticException
    下标越界异常:ArrayIndexOutOfBoundsException
    空指针异常:NullPointerException

73. InputStream字节输入流/OutputStream字节输出流,用于以字节的形式读取和写入数据;两个抽象类;
    FileInputStream 是InputStream子类/FileOutputStream 是OutputStream子类;

74. 这是标准的关闭流的方式
    1. 首先把流的引用声明在try的外面，如果声明在try里面，其作用域无法抵达finally.
    2. 在finally关闭之前，要先判断该引用是否为空
    3. 关闭的时候，需要再一次进行try catch处理

75. Reader字符输入流/Writer字符输出流, 专门用于字符的形式读取和写入数据;两个抽象类;
    FileReader 是Reader子类，以FileReader 为例进行文件读取;
    FileReader是不能手动设置编码方式的，为了使用其他的编码方式，只能使用InputStreamReader来代替;
    InputStreamReader isr = new InputStreamReader(new FileInputStream(f),Charset.forName("UTF-8"));
    OutputStreamWriter/InputStreamReader,将字节流转成字符流;
    BufferedReader/BufferedWriter 缓存字符输入流/缓存字符输出流

76. DataInputStream 数据输入字节流/DataOutputStream 数据输出字节流
    要用DataInputStream 读取一个文件，这个文件必须是由DataOutputStream 写出的，否则会出现EOFException，
    因为DataOutputStream 在写出的时候会做一些特殊标记，只有DataInputStream 才能成功的读取。

77. 对象流指的是可以直接把一个对象以流的形式传输给其他的介质，比如硬盘;
    一个对象以流的形式进行传输，叫做序列化。 该对象所对应的类，必须是实现Serializable接口;
    ObjectOutputStream/ObjectInputStream;

78. 不指定泛型的容器，可以存放任何类型的元素;
    指定了泛型的容器，只能存放指定类型的元素以及其子类;

79. 对于HashMap而言，key是唯一的，不可以重复的。
    所以，以相同的key 把不同的value插入到Map中会导致旧元素被覆盖，只留下最后插入的元素。
    不过，同一个对象可以作为值插入到map中，只要对应的key不一样;

80. Set中的元素，不能重复;严格的说，是没有按照元素的插入顺序排列;
    HashSet的具体顺序，既不是按照插入顺序，也不是按照hashcode的顺序。

81. Set不提供get()来获取指定位置的元素,所以遍历需要用到迭代器，或者增强型for循环;
    Collections是一个类，容器的工具类,就如同Arrays是数组的工具类;

82. HashMap和Hashtable都实现了Map接口，都是键值对保存数据的方式
    区别1：
    HashMap可以存放null, key和value都可以为null;
    Hashtable不能存放null
    区别2：
    HashMap不是线程安全的类
    Hashtable是线程安全的类

81. 根据HashSet和HashMap的关系，我们了解到因为HashSet没有自身的实现，而是里面封装了一个HashMap，所以本质上就是判断HashMap的key是否重复。
    再通过上一步的学习，key是否重复，是由两个步骤判断的：
    hashcode是否一样，如果hashcode不一样，就是在不同的坑里，一定是不重复的
    如果hashcode一样，就是在同一个坑里，还需要进行equals比较
    如果equals一样，则是重复数据
    如果equals不一样，则是不同数据。

82. 使用泛型的好处：
    泛型的用法是在容器后面添加<Type>;
    Type可以是类，抽象类，接口，泛型表示这种容器，只能存放APHero，ADHero就放不进去了。

83. 如果希望只取出，不插入，就使用? extends Hero;
    如果希望只插入，不取出，就使用? super Hero;
    如果希望，又能插入，又能取出，就不要用通配符？;

84. 子类泛型不可以转换为父类泛型; 父类泛型也不能转换成子类泛型; 泛型之间不能相互转型;

85. Stream 和Collection结构化的数据不一样，Stream是一系列的元素，就像是生产线上的罐头一样，一串串的出来。
    管道指的是一系列的聚合操作。
    管道又分3个部分:
    1. 管道源：在这个例子里，源是一个List;
    2. 中间操作： 每个中间操作，又会返回一个Stream，比如.filter()又返回一个Stream, 中间操作是“懒”操作，并不会真正进行遍历;
    3. 结束操作：当这个操作执行后，流就被使用“光”了，无法再被操作。所以这必定是流的最后一个操作。 结束操作不会返回Stream,
       但是会返回int、float、String、 Collection或者像forEach，什么都不返回, 结束操作才进行真正的遍历行为，
       在遍历的时候，才会去进行中间操作的相关判断;

86. 创建多线程有3种方式，分别是继承线程类,实现Runnable接口,匿名类;
    守护线程的概念是： 当一个进程里，所有的线程都是守护线程的时候，结束当前进程。
    守护线程通常会被用来做日志，性能统计等工作。

87. 多线程的同步问题指的是多个线程同时修改一个数据的时候，可能导致的问题;多线程的问题，又叫Concurrency问题;

88. synchronized表示当前线程，独占对象someObject;
    someObject又叫同步对象，所有的对象，都可以作为同步对象,为了达到同步的效果，必须使用同一个同步对象;
    释放同步对象的方式：synchronized块自然结束，或者有异常抛出;

89. 如果一个类，其方法都是有synchronized修饰的，那么该类就叫做线程安全的类;
    同一时间，只有一个线程能够进入这种类的一个实例的去修改数据，进而保证了这个实例中的数据的安全;
    synchronized修饰的静态方法锁定的是这个类的所有对象;

90. wait方法和notify方法，并不是Thread线程上的方法，它们是Object上的方法;
    因为所有的Object都可以被用来作为同步对象，所以准确的讲，wait和notify是同步对象上的方法;
    wait(): 让占用了这个同步对象的线程，临时释放当前的占用，并且等待。所以调用wait是有前提条件的，一定是在synchronized块里，否则就会出错;
    notify(): 通知一个等待在这个同步对象上的线程，你可以苏醒过来了，有机会重新占用当前对象了;
    notifyAll():通知所有的等待在这个同步对象上的线程，你们可以苏醒过来了，有机会重新占用当前对象了;

91. Lock是一个接口，为了使用一个Lock对象，需要用到; Lock lock = new ReentrantLock();
    与 synchronized (someObject) 类似的，lock()方法，表示当前线程占用lock对象，一旦占用，其他线程就不能占用了。
    与 synchronized 不同的是，一旦synchronized 块结束，就会自动释放对someObject的占用。 lock却必须调用unlock方法进行手动释放,
    为了保证释放的执行，往往会把unlock() 放在finally中进行。












